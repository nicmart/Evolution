"r = 3 in
v = @point(uniform(-r, r), uniform(-r, r)) in

symm = e -> flatMap(e, p ->
  cons(p, cons(-p, cons(point(-x(p), y(p)), cons(point(x(p), -y(p)), empty))))
) in

symm(integrate(point(0, 0), v))
  "

// Clifford
scale = 500 in

scaleInv = .002 in

a = -1.4 * scaleInv  in

b = 1.6 * scaleInv in

c = 1.1 in

d = 0.7  in

rnd = @point(uniform(left, right), uniform(bottom, top)) in
trajectory = p -> 

solve1(
  const(p -> -p + scale * point(
    sin(a * y(p)) + c * cos(a * x(p)),
    sin(b * x(p)) + d * cos(b * y(p))
  )),
  p 
) in
   
trajectory(point(0, 0))

// Another Clifford

scale = 500 in

scaleInv = .002 in

a = -1.4 * scaleInv  in

b = 1.6 * scaleInv in

c = 1.1 in

d = 0.7  in

rnd = @point(uniform(left, right), uniform(bottom, top)) in
trajectory = p -> 

solve1(
  const(p -> -p + scale * point(
    sin(a * y(p)) + c * cos(a * x(p)),
    sin(b * x(p)) + d * cos(b * y(p)) + .5227
  )),
  p 
) in
   
trajectory(point(0, 0))

// Double-speed brownian (use torus canvas please)

rnd = r -> n -> take(n, @point(uniform(-r, r), uniform(-r, r))) in
v1 = rnd(2, 1000) in
v2 = rnd(10, 100) in

integrate(point(0, 0), flatten(uniformFrom(2, [v1, v2]))) 

// Serpinsky triangle

p1 = point(0, top) in
p2 = point(left, bottom) in
p3 = point(right, bottom) in

vertexes = uniformFrom(3, [p1, p2, p3]) in

solve1(
  map(vertexes, v -> p -> -p + 0.5 * (v + p)),
  point(0, 0)
)

// fix is broken
"sliding = fix(self ->
    ts -> f -> mapCons(ts,
      t1 -> tail1 -> mapCons(tail1,
        t2 -> tail2 -> cons(f(t1, t2), self(tail1, f))
      )
    )
) in

noConsec = points -> flatMap(
  sliding(points, x1 -> x2 -> if(eq(x1, x2),  empty, cons(x1, empty))),
  x -> x
) in

xs = uniformChoice(point(0, 0), point(100, 200), point(-100, -100)) in

noConsec(xs)"

// fix is broken
"let(
  sliding,
  fix(self ->
    ts -> f -> mapCons(ts,
      t1 -> tail1 -> mapCons(tail1,
        t2 -> tail2 -> cons(f(t1, t2), self(tail1, f))
      )
    )
  ),

let(noConsec, points -> flatMap(sliding(points, x1 -> x2 -> if(eq(x1, x2),  empty, cons(x1, empty))), x -> x),

let(p1, point(left, top),
let(p2, point(left, bottom),
let(p3, point(right, top),
let(p4, point(right, bottom),

let(vertexes, noConsec(uniformChoice(p1, p2, p3, p4)),
k = .06 in
 
let(f, v -> p -> -p + k * v + (-k + 1) * p,
solve1(
  map(vertexes, v -> p -> -p + f(v, p)),
  point(0, 0)
)
 
))))))))"


// Grid of brownians
"r = 2 in
l = 100 in
gridSize = 100 in

rndPoint = @point(uniformDiscrete(left, right, gridSize), uniformDiscrete(bottom, top, gridSize)) in
brownian = p -> take(l,integrate(p, @point(uniform(-r, r), uniform(-r, r)))) in

flatMap(rndPoint, brownian)"


// Grid of symmetric brownians
"r = 3 in
l = 100 in
gridSize = 100 in

symm = e -> flatMap(e, p -> 
  cons(p, cons(-p, cons(point(-x(p), y(p)), cons(point(x(p), -y(p)), empty)))
)) in

translatedSymm = p -> e -> map(symm(map(e, x -> -p + x)), x -> p + x) in

rndPoint = @point(uniformDiscrete(left, right, gridSize), uniformDiscrete(bottom, top, gridSize)) in
brownian = p -> take(l, integrate(p, @point(uniform(-r, r), uniform(-r, r)))) in

flatMap(rndPoint, p -> translatedSymm(p, brownian(p)))"

// Brownian carpet
gridSize = 200 in
r = 6 in
xs = take(20, integrate(left, const(gridSize))) in
ys = take(10, integrate(bottom, const(gridSize))) in

points = flatMap(xs, x -> map(ys, y -> point(x, y))) in

symm = e -> flatMap(e, p -> 
  [p, -p, point(-x(p), y(p)), point(x(p), -y(p))]
) in

brownian = symm(integrate(point(0, 0), @point(uniform(-r, r), uniform(-r, r)))) in

flatMap(brownian, p -> map(points, q -> p + q))

// Grid of squared brownians
gridSize = 100 in

symm = e -> flatMap(e, p -> 
  [p, -p, point(-x(p), y(p)), point(x(p), -y(p))]
) in

translatedSymm = p -> e -> map(symm(map(e, x -> -p + x)), x -> p + x) in

rndPoint = @point(uniformDiscrete(left, right, gridSize), uniformDiscrete(bottom, top, gridSize)) in
  
l = 100 in
step = 10 in
ps = uniformFrom(4, [point(1, 0), point(0, 1), point(-1, 0), point(0, -1)]) in
vs = flatMap(ps, p -> take(step, const(p))) in
evo = p ->  take(l, integrate(p, vs)) in 
     
flatMap(rndPoint, p -> translatedSymm(p, evo(p)))

// Concentric circles

r1 = 300 in
w1 = .001 in
r2 = 100 in
w2 = .002 in
r3 = 100 in
w3 = 1 in
r4 = 10 in
w4 = .008 in
r5 = 100 in
w5 = .008 in

circle = r -> w -> polar(const(r), integrate(0, const(w))) in



circle(r1, w1) +
circle(r2, w2) +
circle(r3, w3) +
circle(r4, w4) +
circle(r5, w5)


// Grid of squared and rounded brownians

l = 200 in
gridSize = 200 in

symm = e -> flatMap(e, p -> 
  cons(p, cons(-p, cons(point(-x(p), y(p)), cons(point(x(p), -y(p)), empty)))
)) in

translatedSymm = p -> e -> map(symm(map(e, x -> -p + x)), x -> p + x) in

rndPoint = @point(uniformDiscrete(left, right, gridSize), uniformDiscrete(bottom, top, gridSize)) in

r = 20 in
v = .3 in
w = v / r in

arcLength =floor(.5 * PI / w) in
arc = angle -> take(arcLength, @polar(const(r * w), integrate(angle, const(w)))) in  
segmentLength = floor(r / v) in  
segment = p -> take(segmentLength, const(v * p)) in 
vs = uniformFrom(8, [
  arc(0), arc(PI / 2), arc(PI), arc(3 * PI / 2),
  segment(point(1, 0)), segment(point(0, 1)), segment(point(-1, 0)), segment(point(0, -1))
]) in 

evo = p -> take(floor(1 + l / v), integrate(p, flatMap(vs, x -> x))) in


flatMap(rndPoint, p -> translatedSymm(p, evo(p)))

// Vortex

a = -.000001 in
k = 0.01 in
rnd = @point(uniform(left, right), uniform(bottom, top)) in

trajectory = p -> 

solve1(
  const(q -> k * point(
     -y(q) + a * x(q) * norm(q)^2,
     x(q) + a * y(q) * norm(q)^2
  )),
  p
) in


flatMap(rnd, p -> take(100, trajectory(p)))

// Grid of concentric circles
r = .03 in
s = 100 in
g = 100 in

mid = point(g/2, g/2) in
vectorField = p -> r * (-mid +point(y(p) % g, (-x(p)) % g)) in
points = @point(uniform(left, right), uniform(bottom, top)) in

line = p -> solve1(
  const(vectorField),
  p
) in

flatMap(points, p -> take(s, line(p)))

 
Grid of rombuses

r = .01 in
s = 60 in
g = 150 in

a = 0 in b = 1 in c = -1 in d = 0 in

mid = point(g/2, g/2) in


singleVectorField = p -> point(
  a * x(p) + b * y(p),
  c * x(p) + d * y(p)
) in

pointSign = p -> (abs(x(p)) + abs(y(p))) * point(sign(x(p)), sign(y(p))) in

pointMod = p -> -mid + point(
  x(p) % g,
  y(p) % g
) in

vectorField = p -> r * (singleVectorField(pointSign(pointMod(p)))) in

points = @point(uniform(left, right), uniform(bottom, top)) in

line = p -> solve1(
  const(vectorField),
  p
) in

flatMap(points, p -> take(s, line(p)))

// Rotational-symmetric brownian
n = 8 in
r = 3 in

a = 1 in b = 1 in c = 1 in d = 1 in

ps = integrate(point(0, 0), @point(uniform(-r, r), uniform(-r, r))) in

angles = n -> take(n, integrate(0, const(2 * PI / toDbl(n)))) in

rotate = angle -> p -> point(
  x(p) * cos(angle) +-y(p) * sin(angle),
  x(p) * sin(angle) + y(p) * cos(angle)
) in

nAngles = angles(n) in

flatMap(ps, p -> map(angles(n), a -> rotate(a, p)))



// Spiral and then 2nd order brownian

r = .02 in
w = .01 in

r2 = .02 in

spiral = @polar(integrate(0, const(r)), integrate(0, const(w))) in

speed1 = mapCons(uniform(1000, 3000), n -> o -> take(floor(n), map(spiral, v -> p -> v - p))) in

speed2v = integrate(point(0, 0), @point(uniform(-r2, r2), uniform(-r2, r2))) in

speed2 = take(1000, map(speed2v, v -> p -> v)) in

speed = concat(speed1, speed2) in

solve1(
  speed,
  point(0, 0)
)


// Broken

"r = 2 in
w = .01 in

r2 = .02 in

spiral = @polar(integrate(0, const(r)), integrate(0, const(w))) in
spiralAcc = map(derive2(spiral), p -> (x -> v -> p - v)) in
tangentAcc = const(x -> v -> point(0, 0)) in

spiralAccs = map(uniform(1000, 3000), n -> take(floor(n), spiralAcc)) in
tangentAccs = map(uniform(800, 1000), n -> take(floor(n), tangentAcc)) in

acc = flatMap(zipWith(spiralAccs, tangentAccs, x -> y -> concat(x, y)), z -> z) in

solve2(
  acc,
  point(0, 0),
  point(0, 0)
)
"

// Broken
"r = 2 in
w = 0.01 in

r2 = .02 in
c = 5 in


spiral = @polar(integrate(0, const(r)), integrate(0, const(w))) in
spiralAcc = map(derive2(spiral), p -> (x -> v -> versor(p - v))) in
tangentAcc = const(x -> v -> point(0, 0)) in



spiralAccs = map(uniform(3000, 6000), n -> take(floor(n), spiralAcc)) in
tangentAccs = map(uniform(800, 1000), n -> take(floor(n), tangentAcc)) in

acc = flatten(zipWith(spiralAccs, tangentAccs, x -> y -> concat(x, y))) in

solve2(
  acc,
  point(0, 0),
  point(0, 0)
)
"

// Broken (mapWithDerivative)
"r = .1 in
w = 0.01 in

r2 = .02 in
c = 5 in


spiral = @polar(integrate(0, const(r)), integrate(0, const(w))) in

rotate = p -> point(y(p), -x(p)) in

flatten(mapWithDerivative(
  x -> v -> take(100, integrate(x, const(0.1 * rotate(v)))),
  spiral
))"


// Broken (mapWithDerivative)
"
k = 10 in
step = 1 in
radius = 20 in
angularSpeedFactor = 1 in
straightStepLength = 100 in
maxStraightSteps = 8 in
numberOfParallelLines = 4 in
distanceBetweenParallelLines = 10 in

angle = 3 * PI / 2 in


rotate = v -> alpha -> point(x(v) * cos(alpha) - y(v) * sin(alpha), x(v) * sin(alpha) + y(v) * cos(alpha)) in

rotation = v -> map(
  take(1 + floor(angle * radius / angularSpeedFactor), integrate(0, const(angularSpeedFactor / radius))),
  a -> angularSpeedFactor * rotate(v, -a)
) in

s = n -> v -> concat(take(floor(n), const(v)), rotation(v)) in

versors = flatten(const([point(step, 0), point(0, step), point(-step, 0), point(0, -step)])) in

lengths = uniformFrom(maxStraightSteps, map(integrate(3, const(1)), k -> straightStepLength * k + 2 * radius)) in 

speed = flatten(zipWith(lengths, versors, s)) in



flatten(mapWithDerivative(
  x -> v -> take(numberOfParallelLines, integrate(x, const(distanceBetweenParallelLines *rotate(versor(v), pi / 2)))),
  integrate(point(0, 0), speed)
))

"

// Straight lines with spiral angles
k = 2 in
step = 1 in
radius = 5 in
spiralDistances = .2 in
numberOfRotations = 3 in
angularSpeedFactor = .2 in
straightStepLength = 50 in
maxStraightSteps = 32 in


angle = 3 * PI / 2 in
rotationIterations = numberOfRotations * (1 + floor(angle * radius / angularSpeedFactor)) in


rotate = v -> alpha -> spiralDistances * alpha *  point(x(v) * cos(alpha) - y(v) * sin(alpha), x(v) * sin(alpha) + y(v) * cos(alpha)) in

rotation = v -> map(
  take(rotationIterations, integrate(0, const(angularSpeedFactor / radius))),
  a -> angularSpeedFactor * rotate(v, -a)
) in

s = n -> v -> concat(take(floor(n), const(v)), rotation(v)) in

versors = flatten(const([point(step, 0), point(0, step), point(-step, 0), point(0, -step)])) in

lengths = uniformFrom(maxStraightSteps, map(integrate(3, const(1)), k -> straightStepLength * k + 2 * radius)) in 

speed = flatten(zipWith(lengths, versors, s)) in



integrate(point(0, 0), speed)

// BROKEN: mapWithDerivative

"viscosity = .001 in
k = 0 in
randomForceStrength = .1 in
orthogonalLineLength = 50 in
orthogonalFactor = .3 in

randomForces = @point(
  uniform(-randomForceStrength, randomForceStrength),
  uniform(-randomForceStrength, randomForceStrength)
) in

acceleration = r -> x -> v -> r -viscosity * v + k * x in

line = solve2(
  map(randomForces, acceleration),
  point(0, 0),
  point(0, 0)
) in

flatten(mapWithDerivative(
  p -> v ->
    rotated = orthogonalFactor * point(y(v), -x(v)) in
    start = p - (toDbl(orthogonalLineLength)/2) * rotated in
    integrate(start, take(orthogonalLineLength, const(rotated))),
  line
))"

// Perlin noise 1
Z
rndPoint = @point(uniform(left, right), uniform(bottom, top)) in
f = 60 in
v = 2 in

withFirst(noise, n ->
  withFirst(uniform(1, 256), r ->
    line = p -> solve1(
      const(q -> polar(v, 6 * (2^.5) * PI * n((1 / f) * q))),
      p
    ) in
    flatMap(
      rndPoint,
      p -> take(300, line(p))
    )
  )
) 

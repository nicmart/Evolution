

"flatMap(uniform(left, right), x -> take(30, flatMap(uniform(bottom, top), y -> point(integrate(x, const(1)), solve1(const(z -> multiply(0.00001, multiply(z, 1 + -z))), y)))))"

"l = 10 in
hSpeed = 2 in
w = 0.01 in
amplitude = 10 in

rndPoint =@point(uniform(left, right), uniform(bottom, top)) in

trajectory = p -> @point(
  integrate(x(p), const(hSpeed)),
  solve1(const(z -> amplitude * sin(w * z)), y(p))
) in 

flatMap(
  rndPoint,
  p -> take(
    l,
    trajectory(p)
  ) 
)"

"flatMap(uniform(left, right), x -> take(10, flatMap(uniform(bottom, top), y -> point(integrate(x, const(1)), solve1(const(z -> multiply(3, add(sin(0.003 * z), add(sin(0.05 * z), sin(0.006 * z))))), y)))))"

"flatMap(
  uniform(left, right),
  x -> take(
    10000,
    flatMap(
      uniform(bottom, top),
      y -> map(
        @point(
          solve2(map(uniform(-1, 1), r -> z -> v -> 0.1 * r + 0 * z + -0.1 * v), 0, 0),
          solve2(map(uniform(-1, 1), r -> z -> v -> 0.1 * r + -0.001 *  z + -0.003 * v), 0, 0)
        ),
        p -> p + point(x, y)
      )
    )
  )
)"

"flatMap(uniform(left, right), x -> take(10000, flatMap(uniform(bottom, top), y -> map(point(solve2(map(uniform(-1, 1), r -> z -> v -> 0.1 * r + 0 * z + -0.1 * v), 0, 0), solve2(map(uniform(-1, 1), r -> z -> v -> 0.1 * r + -0.001 * z + -0.003 * v), 0, 0)), p -> add(p, point(x, y))))))"

"flatMap(uniform(left, right), x -> take(10000, flatMap(uniform(bottom, top), y -> map(point(solve2(map(uniform(-1, 1), r -> z -> v -> 0.1 * r + -0.001 * z + -0.003 * v), 0, 0), solve2(map(uniform(-1, 1), r -> z -> v -> 0.1 * r + -0.001 * z + -0.003 * v), 0, 0)), p -> add(p, point(x, y))))))"

"flatMap(uniform(left, right), x -> take(10000, flatMap(uniform(bottom, top), y -> map(point(solve2(map(uniform(-1, 1), r -> z -> v -> 0.1 * r + -0.001 * z + -0.03 * v), 0, 0), solve2(map(uniform(-1, 1), r -> z -> v -> 0.1 * r + -0.0001 * z + -0.0003 * v), 0, 0)), p -> add(p, point(x, y))))))"

"let(radius, 2, let(friction, 0.06, solve2(map(@point(uniform(-radius, radius), uniform(-radius, radius)), r -> x -> v -> r + -friction * v), point(0, 0), point(0, 0))))"

"let(radius, 0.00001, let(viscosity, radius * 0.01, let(k, radius * 3, let(rnd, @point(uniform(-radius, radius), uniform(-radius, radius)), let(v, solve2(map(rnd, r -> x -> v -> r + -viscosity * v + -k * x), point(0, 0), point(0, 0)), integrate(point(0, 0), v))))))"

"let(radius, 0.001,
let(viscosity, radius * 9.995,
let(k, radius * 10,
let(rnd, @point(uniform(-radius, radius), uniform(-radius, radius)),
let(v, solve2(map(rnd, r -> x -> v -> r + -viscosity * v + -k * x), point(0, 0), point(0, 0)),

integrate(point(0, 0), v)


)))))"

"let(circle, r -> w -> polar(const(r), integrate(0, const(w))),
let(rndPoint, @point(uniform(left, right), uniform(bottom, top)),
let(radiuses, uniform(1, 30),

flatMap(
  rndPoint,
  p -> take(100, flatMap(radiuses, r -> map(circle(r, .1), p2 -> p + p2)))
)

)))"

"let(k, .0003,
let(h, .003,
let(rnd, @point(uniform(left, right), uniform(bottom, top)),
let(trajectory, p -> 

solve1(
  const(p -> point(h * y(p), -k * x(x))),
  p
),

flatMap(rnd, p -> take(100, trajectory(p)))

))))"

"r = 3 in
v = @point(uniform(-r, r), uniform(-r, r)) in

symm = e -> flatMap(e, p ->
  cons(p, cons(-p, cons(point(-x(p), y(p)), cons(point(x(p), -y(p)), empty))))
) in

symm(integrate(point(0, 0), v))
  "

"let(scale, 500,
let(scaleInv, .002,
let(a, -1.4 * scaleInv ,
let(b, 1.6 * scaleInv,
let(c, 1.1,
let(d, 0.7 ,
let(rnd, @point(uniform(left, right), uniform(bottom, top)),
let(trajectory, p -> 

solve1(
  const(p -> -p + scale * point(
    sin(a * y(p)) + c * cos(a * x(p)),
    sin(b * x(p)) + d * cos(b * y(p))
  )),
  p 
),  
   
trajectory(point(0, 0))

))))))))"

"let(scale, .01,
let(scaleInv, .002,
let(a, -1.4 * scaleInv ,
let(b, 1.6 * scaleInv,
let(rnd, @point(uniform(left, right), uniform(bottom, top)),
let(trajectory, p -> 
    
solve1(
  const(p -> scale * point(
    y(p),
    a * x(p) * (1 +-x(p))
  )),
  p 
),  
   
flatMap(rnd, p -> take(100, trajectory(p)))

))))))"

"let(scale, 500,
let(scaleInv, .002,
let(a, -1.4 * scaleInv ,
let(b, 1.6 * scaleInv,
let(c, 1.1,
let(d, 0.7 ,
let(rnd, @point(uniform(left, right), uniform(bottom, top)),
let(trajectory, p -> 

solve1(
  const(p -> -p + scale * point(
    sin(a * y(p)) + c * cos(a * x(p)),
    sin(b * x(p)) + d * cos(b * y(p)) + .5227
  )),
  p 
),  
   
trajectory(point(0, 0))

))))))))"

"let(rnd, @point(uniform(left, right), uniform(bottom, top)),
let(k, 1000000,
let(trajectory, p -> 
    
solve1(
  const(p -> point(
    x(p)^2 + -y(p)^2,
    8 * x(p) * y(p)
  )),
  (1 / k) * p 
),   
   
flatMap(rnd, p -> take(100, map(trajectory(p), q -> k * q )))

)))  "

"let(rnd, r -> n -> take(n, @point(uniform(-r, r), uniform(-r, r))),

integrate(point(0, 0), flatMap(uniformChoice(rnd(2, 1000), rnd(10, 100)), x -> x)) 
 
)"

"let(p1, point(0, top),
let(p2, point(left, bottom),
let(p3, point(right, bottom),

let(vertexes, uniformChoice(p1, p2, p3),

solve1(
  map(vertexes, v -> p -> -p + 0.5 * (v + p)),
  point(0, 0)
)

))))"

"let(p1, point(0, top),
let(p2, point(left, bottom),
let(p3, point(right, bottom),

let(rnd, @point(uniform(left, right), uniform(bottom, top)),
let(vertexes, mapCons(rnd, p1 -> t1 -> mapCons(t1, p2 -> t2 -> mapCons(t2, p3 -> t3 -> uniformChoice(p1, p2, p3)))),

solve1(
  map(vertexes, v -> p -> -p + 0.5 * (v + p)),
  point(0, 0)
)

))))) "

"let(rnd, r -> n -> take(n, @point(uniform(-r, r), uniform(-r, r))),
let(c, r -> n -> take(n, flatMap(@point(uniform(-r, r), uniform(-r, r)), p -> const(p))),

integrate(
  point(0, 0),
  flatMap(
    flatMap(const(cons(rnd(3, 500), cons(c(3, 30), empty))), x -> x),
    x -> x
  )
) 
 
))   "

"let(p1, point(left, top),
let(p2, point(right, top),
let(p3, point(right, bottom),
let(p4, point(left, bottom),
let(rnd, take(1, @point(uniform(-10, 10), uniform(-10, 10))),
let(vertexes, uniformChoice(p4, p1, p3),

solve1(
  flatMap(
    vertexes,
    v -> map(rnd,  r -> p -> -p + r +.5 * (v + p))
  ),
  p1
)
 
))))))"

"sliding = fix(self ->
    ts -> f -> mapCons(ts,
      t1 -> tail1 -> mapCons(tail1,
        t2 -> tail2 -> cons(f(t1, t2), self(tail1, f))
      )
    )
) in

noConsec = points -> flatMap(
  sliding(points, x1 -> x2 -> if(eq(x1, x2),  empty, cons(x1, empty))),
  x -> x
) in

xs = uniformChoice(point(0, 0), point(100, 200), point(-100, -100)) in

noConsec(xs)"

"let(
  sliding,
  fix(self ->
    ts -> f -> mapCons(ts,
      t1 -> tail1 -> mapCons(tail1,
        t2 -> tail2 -> cons(f(t1, t2), self(tail1, f))
      )
    )
  ),

let(noConsec, points -> flatMap(sliding(points, x1 -> x2 -> if(eq(x1, x2),  empty, cons(x1, empty))), x -> x),

let(p1, point(left, top),
let(p2, point(left, bottom),
let(p3, point(right, top),
let(p4, point(right, bottom),

let(vertexes, noConsec(uniformChoice(p1, p2, p3, p4)),
let(k, .06, 
let(f, v -> p -> -p + k * v + (-k + 1) * p,
solve1(
  map(vertexes, v -> p -> -p + f(v, p)),
  point(0, 0)
)
 
)))))))))"

"r = 2 in
l = 100 in
gridSize = 100 in

rndPoint = @point(uniformDiscrete(left, right, gridSize), uniformDiscrete(bottom, top, gridSize)) in
brownian = p -> take(l,integrate(p, @point(uniform(-r, r), uniform(-r, r)))) in

flatMap(rndPoint, brownian)"

"r = 3 in
l = 100 in
gridSize = 100 in

symm = e -> flatMap(e, p -> 
  cons(p, cons(-p, cons(point(-x(p), y(p)), cons(point(x(p), -y(p)), empty)))
)) in

translatedSymm = p -> e -> map(symm(map(e, x -> -p + x)), x -> p + x) in

rndPoint = @point(uniformDiscrete(left, right, gridSize), uniformDiscrete(bottom, top, gridSize)) in
brownian = p -> take(l, integrate(p, @point(uniform(-r, r), uniform(-r, r)))) in

flatMap(rndPoint, p -> translatedSymm(p, brownian(p)))"

"r = 3 in
l = 40 in
gridSize = 50 in

symm = e -> flatMap(e, p -> 
  cons(p, cons(-p, cons(point(-x(p), y(p)), cons(point(x(p), -y(p)), empty)))
)) in

translatedSymm = p -> e -> map(symm(map(e, x -> -p + x)), x -> p + x) in

rndPoint = @point(uniformDiscrete(left, right, gridSize), uniformDiscrete(bottom, top, gridSize)) in
brownian = p -> take(l, integrate(p, @point(uniform(-r, r), uniform(-r, r)))) in

flatMap(rndPoint, p -> translatedSymm(p, brownian(p)))"

"gridSize = 200 in
r = 6 in
xs = take(20, integrate(left, const(gridSize))) in
ys = take(10, integrate(bottom, const(gridSize))) in

points = flatMap(xs, x -> map(ys, y -> point(x, y))) in

symm = e -> flatMap(e, p -> 
  cons(p, cons(-p, cons(point(-x(p), y(p)), cons(point(x(p), -y(p)), empty)))
)) in

brownian = symm(integrate(point(0, 0), @point(uniform(-r, r), uniform(-r, r)))) in

flatMap(brownian, p -> map(points, q -> p + q))
"

"r = 3 in
gridSize = 100 in

symm = e -> flatMap(e, p -> 
  cons(p, cons(-p, cons(point(-x(p), y(p)), cons(point(x(p), -y(p)), empty)))
)) in



translatedSymm = p -> e -> map(symm(map(e, x -> -p + x)), x -> p + x) in

rndPoint = <point>(uniformDiscrete(left, right, gridSize), uniformDiscrete(bottom, top, gridSize)) in
brownian = p -> take(floor(50 *(1 + sin(.05 * x(p)))), integrate(p, <point>(uniform(-r, r), uniform(-r, r)))) in

flatMap(rndPoint, p -> translatedSymm(p, brownian(p)))    "

"flatMap(
  uniform(left, right),
  x -> take(
    10000,
    flatMap(
      uniform(bottom, top),
      y -> map(
        @point(
          solve2(map(uniform(-1, 1), r -> z -> v -> 0.1 * r + 0 * z + -0.1 * v), 0, 0),
          solve2(map(uniform(-1, 1), r -> z -> v -> 0.1 * r + -0.001 *  z + -0.003 * v), 0, 0)
        ),
        p -> p + point(x, y)
      )
    )
  )
)"

"gridSize = 100 in

symm = e -> flatMap(e, p -> 
  cons(p, cons(-p, cons(point(-x(p), y(p)), cons(point(x(p), -y(p)), empty)))
)) in

translatedSymm = p -> e -> map(symm(map(e, x -> -p + x)), x -> p + x) in

rndPoint = @point(uniformDiscrete(left, right, gridSize), uniformDiscrete(bottom, top, gridSize)) in
  
l = 100 in
step = 10 in
ps = uniformFrom(4, [point(1, 0), point(0, 1), point(-1, 0), point(0, -1)]) in
vs = flatMap(ps, p -> take(step, const(p))) in
evo = p ->  take(l, integrate(p, vs)) in 
     
flatMap(rndPoint, p -> translatedSymm(p, evo(p)))     "

"r1 = 300 in
w1 = .001 in
r2 = 100 in
w2 = .002 in
r3 = 100 in
w3 = 1 in
r4 = 10 in
w4 = .008 in
r5 = 100 in
w5 = .008 in

circle = r -> w -> polar(const(r), integrate(0, const(w))) in



circle(r1, w1) +
circle(r2, w2) +
circle(r3, w3) +
circle(r4, w4) +
circle(r5, w5)"


"l = 200 in
gridSize = 200 in

symm = e -> flatMap(e, p -> 
  cons(p, cons(-p, cons(point(-x(p), y(p)), cons(point(x(p), -y(p)), empty)))
)) in

translatedSymm = p -> e -> map(symm(map(e, x -> -p + x)), x -> p + x) in

rndPoint = @point(uniformDiscrete(left, right, gridSize), uniformDiscrete(bottom, top, gridSize)) in
//evo = p -> take(l, integrate(p, @point(uniform(-r, r), uniform(-r, r)))) in

r = 20 in
v = .3 in
w = v / r in

arcLength =floor(.5 * PI / w) in
arc = angle -> take(arcLength, polar(const(r * w), integrate(angle, const(w)))) in  
segmentLength = floor(r / v) in  
segment = p -> take(segmentLength, const(v * p)) in 
vs = uniformChoice(
  arc(0), arc(PI / 2), arc(PI), arc(3 * PI / 2),
  segment(point(1, 0)), segment(point(0, 1)), segment(point(-1, 0)), segment(point(0, -1))
) in 

evo = p -> take(floor(1 + l / v), integrate(p, flatMap(vs, x -> x))) in


flatMap(rndPoint, p -> translatedSymm(p, evo(p)))"

"a = -.000001 in
k = 0.01 in
rnd = @point(uniform(left, right), uniform(bottom, top)) in

//eq = const(p -> point(k *y(p), - h * x(p)^3 + h * x(p))) in

sqNorm = p -> x(p)^2 + y(p)^2 in

trajectory = p -> 

solve1(
  const(q -> k * point(
     -y(q) + a * x(q) * sqNorm(q),
     x(q) + a * y(q) * sqNorm(q)
  )),
  p
) in


flatMap(rnd, p -> take(100, trajectory(p)))"

"a = -.000001 in
k = 0.01 in
rnd = @point(uniform(left, right), uniform(bottom, top)) in

//eq = const(p -> point(k *y(p), - h * x(p)^3 + h * x(p))) in

sqNorm = p -> x(p)^2 + y(p)^2 in

trajectory = p -> 

solve1(
  const(q -> k * point(
     -y(q) + a * x(q) * sqNorm(q),
     x(q) + a * y(q) * sqNorm(q)
  )),
  p
) in


flatMap(rnd, p -> take(100, trajectory(p)))"

"a = -.000001 in
k = 0.01 in

rnd = polar(uniform(0, top), uniform(0, 2 * PI)) in
sqNorm = p -> x(p)^2 + y(p)^2 in

trajectory = p -> 

solve1(
  const(q -> k * (point(-y(q), x(q)) + a * sqNorm(q) * q) ),
  p
) in


flatMap(rnd, p -> take(1000, trajectory(p)))"

"k = 0.01 in
l = 100 in
a = -1 in
b = -2 in
c = 0 in
zoom = 1 in

rnd = @point(uniform(left, right), uniform(bottom, top)) in
//sqNorm = p -> x(p)^2 + y(p)^2 in

//vectorField = p -> k * p in
vectorField = z -> p -> k * point(y(p), a * x(p) + b * y(p) + c ) in

trajectory = p -> 

map(solve1(
  const(vectorField(zoom)),
  (1 / zoom) * p
), p -> zoom * p) in
 

flatMap(rnd, p -> take(l, trajectory(p))) "

"r = .03 in
s = 100 in
g = 100 in

mid = point(g/2, g/2) in
vectorField = p -> r * (-mid +point(y(p) % g, (-x(p)) % g)) in
points = <point>(uniform(left, right), uniform(bottom, top)) in

line = p -> solve1(
  const(vectorField),
  p
) in

flatMap(points, p -> take(s, line(p)))"

"
a = 48271 in b = 0 in m = 2^31 +-1 in
k = 2 / m in

gridSize = 100 in

rnd = prev -> (a * prev + b) % m in
normalise = prev -> 2 * rnd(prev) / m + -1 in 

speed = p -> point(
  normalise(rnd(x(p) + gridSize * y(p))),
  normalise(rnd(y(p)+  gridSize * x(p)))
) in

randomPoint = <point>(uniform(left, right), uniform(bottom, top)) in


gridPoint = p -> point(
  toDbl(floor(x(p) / gridSize)),
  toDbl(floor(y(p) / gridSize))
) + point(gridSize, gridSize) in

line = p -> take(20, integrate(p, <speed(gridPoint(p))>)) in

flatMap(randomPoint, line)



 
"

"r = .03 in
s = 30 in
g = 200 in

a = 0 in b = 1 in c = -1 in d = 0 in

mid = point(g/2, g/2) in


singleVectorField = p -> point(
  a * x(p) + b * y(p),
  c * x(p) + d * y(p)
) in

pointSign = p -> point(sign(x(p)), sign(y(p))) in

pointMod = p -> -mid + point(
  x(p) % g,
  y(p) % g
) in

vectorField = p -> r * (singleVectorField(pointMod(p))) in

points = <point>(uniform(left, right), uniform(bottom, top)) in

line = p -> solve1(
  const(vectorField),
  p
) in

flatMap(points, p -> take(s, line(p)))"

"r = .01 in
s = 60 in
g = 150 in

a = 0 in b = 1 in c = -1 in d = 0 in

mid = point(g/2, g/2) in


singleVectorField = p -> point(
  a * x(p) + b * y(p),
  c * x(p) + d * y(p)
) in

pointSign = p -> (abs(x(p)) + abs(y(p))) * point(sign(x(p)), sign(y(p))) in

pointMod = p -> -mid + point(
  x(p) % g,
  y(p) % g
) in

vectorField = p -> r * (singleVectorField(pointSign(pointMod(p)))) in

points = <point>(uniform(left, right), uniform(bottom, top)) in

line = p -> solve1(
  const(vectorField),
  p
) in

flatMap(points, p -> take(s, line(p)))"

"n = 8 in
r = 3 in

a = 1 in b = 1 in c = 1 in d = 1 in

ps = integrate(point(0, 0), <point>(uniform(-r, r), uniform(-r, r))) in

angles = n -> take(n, integrate(0, <2 * PI / toDbl(n)>)) in

rotate = angle -> p -> point(
  x(p) * cos(angle) +-y(p) * sin(angle),
  x(p) * sin(angle) + y(p) * cos(angle)
) in


symm = n -> p -> map(angles(n), a -> rotate(a, p)) in

//flatMap(ps, p -> [p, -p, rotate(PI/2, p), rotate(-PI/2, p)])

flatMap(ps, p -> map(angles(n), a -> rotate(a, p)))"

"
a = -.1 in b = -1 in c = 1 in
rbrownian = 1 in
rf = 100 in
e = 1000 in

dist = map(uniform(0, 1), x -> rf *(2 * x^e + -1)) in

n = <point>(dist, dist) in

oscillator = solve2(
  map(n, rn -> x -> v -> a * x + b * v + rn),
  point(0, 0),
  point(0, 0)
) in


brownian = integrate(point(0, 0), <point>(
  uniform(-rbrownian, rbrownian),
  uniform(-rbrownian, rbrownian)
)) in

brownian <+> oscillator

"

"
a = -.1 in b = -1 in c = 1 in
rbrownian = 2 in
rf = 100 in
mu = 1 in
sigma = 1 in
k = 3 in

angles = n -> take(n, integrate(0, <2 * PI / toDbl(n)>)) in

rotate = angle -> p -> point(
  x(p) * cos(angle) +-y(p) * sin(angle),
  x(p) * sin(angle) + y(p) * cos(angle)
) in

dist = normal(mu, sigma) in

n = <k> <*> <point>(dist, dist) in

oscillator = solve2(
  map(n, rn -> x -> v -> a * x + b * v + rn),
  point(0, 0),
  point(0, 0)
) in


brownian = integrate(point(0, 0), <point>(
  uniform(-rbrownian, rbrownian),
  uniform(-rbrownian, rbrownian)
)) in

evo = brownian <+> oscillator in

flatMap(evo, p -> map(angles(7), a -> rotate(a, p)))


"

"gridSize = 100 in
l = 10 in

nX = (right +- left) / gridSize in
nY = (top +- bottom) / gridSize in
tot = floor(nX * nY) in

gridPointsX = take(floor(nX), integrate(left, <gridSize>)) in
gridPointsY = take(floor(nY), integrate(bottom, <gridSize>)) in

gridPoints = flatMap(gridPointsX, x -> map(gridPointsY, y -> point(x, y))) in



rndPointInCell = <point>(uniform(0, gridSize), uniform(0, gridSize)) in

angles = uniform(0, 2 * PI) in

trajectoriesFunc = zipWith(gridPoints, angles, g -> a -> p -> integrate(g + p, <polar(3, a)>)) in

trajectories = zipWith(rndPointInCell, uniformFrom(tot, trajectoriesFunc), p -> f -> f(p)) in


flatMap(trajectories, x -> take(l, x))
"

"r = .02 in
w = .01 in

r2 = .02 in

spiral = @polar(integrate(0, const(r)), integrate(0, const(w))) in

speed1 = mapCons(uniform(1000, 3000), n -> o -> take(floor(n), map(spiral, v -> p -> v - p))) in

speed2v = integrate(point(0, 0), @point(uniform(-r2, r2), uniform(-r2, r2))) in

speed2 = take(1000, map(speed2v, v -> p -> v)) in

speed = concat(speed1, speed2) in

solve1(
  speed,
  point(0, 0)
)
"

"r = 2 in
w = .01 in

r2 = .02 in

spiral = @polar(integrate(0, const(r)), integrate(0, const(w))) in
spiralAcc = map(derive2(spiral), p -> (x -> v -> p - v)) in
tangentAcc = const(x -> v -> point(0, 0)) in

spiralAccs = map(uniform(1000, 3000), n -> take(floor(n), spiralAcc)) in
tangentAccs = map(uniform(800, 1000), n -> take(floor(n), tangentAcc)) in

acc = flatMap(zipWith(spiralAccs, tangentAccs, x -> y -> concat(x, y)), z -> z) in

solve2(
  acc,
  point(0, 0),
  point(0, 0)
)
"

"r = 2 in
w = 0.01 in

r2 = .02 in
c = 5 in


spiral = @polar(integrate(0, const(r)), integrate(0, const(w))) in
spiralAcc = map(derive2(spiral), p -> (x -> v -> versor(p - v))) in
tangentAcc = const(x -> v -> point(0, 0)) in



spiralAccs = map(uniform(3000, 6000), n -> take(floor(n), spiralAcc)) in
tangentAccs = map(uniform(800, 1000), n -> take(floor(n), tangentAcc)) in

acc = flatten(zipWith(spiralAccs, tangentAccs, x -> y -> concat(x, y))) in

solve2(
  acc,
  point(0, 0),
  point(0, 0)
)
"

"r = .1 in
w = 0.01 in

r2 = .02 in
c = 5 in


spiral = @polar(integrate(0, const(r)), integrate(0, const(w))) in

rotate = p -> point(y(p), -x(p)) in

flatten(mapWithDerivative(
  x -> v -> take(100, integrate(x, const(0.1 * rotate(v)))),
  spiral
))"

"k = 2 in
step = 1 in
radius = 5 in
angularSpeedFactor = 1 in
straightStepLength = 20 in
maxStraightSteps = 32 in


angle = 3 * PI / 2 in


rotate = v -> alpha -> point(x(v) * cos(alpha) - y(v) * sin(alpha), x(v) * sin(alpha) + y(v) * cos(alpha)) in

rotation = v -> map(
  take(1 + floor(angle * radius / angularSpeedFactor), integrate(0, const(angularSpeedFactor / radius))),
  a -> angularSpeedFactor * rotate(v, -a)
) in

s = n -> v -> concat(take(floor(n), const(v)), rotation(v)) in

versors = flatten(const([point(step, 0), point(0, step), point(-step, 0), point(0, -step)])) in

lengths = uniformFrom(maxStraightSteps, map(integrate(3, const(1)), k -> straightStepLength * k + 2 * radius)) in 

speed = flatten(zipWith(lengths, versors, s)) in



integrate(point(0, 0), speed)

"

"

k = 10 in
step = 1 in
radius = 20 in
angularSpeedFactor = 1 in
straightStepLength = 100 in
maxStraightSteps = 8 in
numberOfParallelLines = 4 in
distanceBetweenParallelLines = 10 in

angle = 3 * PI / 2 in


rotate = v -> alpha -> point(x(v) * cos(alpha) - y(v) * sin(alpha), x(v) * sin(alpha) + y(v) * cos(alpha)) in

rotation = v -> map(
  take(1 + floor(angle * radius / angularSpeedFactor), integrate(0, const(angularSpeedFactor / radius))),
  a -> angularSpeedFactor * rotate(v, -a)
) in

s = n -> v -> concat(take(floor(n), const(v)), rotation(v)) in

versors = flatten(const([point(step, 0), point(0, step), point(-step, 0), point(0, -step)])) in

lengths = uniformFrom(maxStraightSteps, map(integrate(3, const(1)), k -> straightStepLength * k + 2 * radius)) in 

speed = flatten(zipWith(lengths, versors, s)) in



flatten(mapWithDerivative(
  x -> v -> take(numberOfParallelLines, integrate(x, const(distanceBetweenParallelLines *rotate(versor(v), pi / 2)))),
  integrate(point(0, 0), speed)
))

"

"k = 2 in
step = 1 in
radius = 5 in
spiralDistances = .2 in
numberOfRotations = 3 in
angularSpeedFactor = .2 in
straightStepLength = 50 in
maxStraightSteps = 32 in


angle = 3 * PI / 2 in
rotationIterations = numberOfRotations * (1 + floor(angle * radius / angularSpeedFactor)) in


rotate = v -> alpha -> spiralDistances * alpha *  point(x(v) * cos(alpha) - y(v) * sin(alpha), x(v) * sin(alpha) + y(v) * cos(alpha)) in

rotation = v -> map(
  take(rotationIterations, integrate(0, const(angularSpeedFactor / radius))),
  a -> angularSpeedFactor * rotate(v, -a)
) in

s = n -> v -> concat(take(floor(n), const(v)), rotation(v)) in

versors = flatten(const([point(step, 0), point(0, step), point(-step, 0), point(0, -step)])) in

lengths = uniformFrom(maxStraightSteps, map(integrate(3, const(1)), k -> straightStepLength * k + 2 * radius)) in 

speed = flatten(zipWith(lengths, versors, s)) in



integrate(point(0, 0), speed)

"

"viscosity = .001 in
k = 0 in
randomForceStrength = .1 in
orthogonalLineLength = 50 in
orthogonalFactor = .3 in

randomForces = @point(
  uniform(-randomForceStrength, randomForceStrength),
  uniform(-randomForceStrength, randomForceStrength)
) in

acceleration = r -> x -> v -> r -viscosity * v + k * x in

line = solve2(
  map(randomForces, acceleration),
  point(0, 0),
  point(0, 0)
) in

flatten(mapWithDerivative(
  p -> v ->
    rotated = orthogonalFactor * point(y(v), -x(v)) in
    start = p - (toDbl(orthogonalLineLength)/2) * rotated in
    integrate(start, take(orthogonalLineLength, const(rotated))),
  line
))"

"rndPoint = @point(uniform(left, right), uniform(bottom, top)) in
f = 60 in
v = 2 in

mapCons(noise, n -> notUsed ->
  mapCons(uniform(1, 256), r -> notUsed ->
    line = p -> solve1(
      const(q -> polar(v, 6 * (2^.5) * PI * n((1 / f) * q))),
      p
    ) in
    flatMap(
      rndPoint,
      p -> take(300, line(p))
    )
  )
) 
"
